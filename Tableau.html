<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Bang - Final Fix</title>
    <style>
        body { margin: 0; background: black; overflow: hidden; cursor: grab; }
        body:active { cursor: grabbing; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0012);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- CAMERA ---
        let camRadius = 450; 
        let camTheta = Math.PI / 0.1;
        let camPhi = Math.PI / 0.1; 
        
        function updateCamera() {
            camera.position.x = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
            camera.position.y = camRadius * Math.cos(camPhi);
            camera.position.z = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
            camera.lookAt(0, 0, 0);
        }
        updateCamera();

        // --- 1. LE CŒUR (CORE) ---
        const sphereGeo = new THREE.SphereGeometry(12, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const coreSphere = new THREE.Mesh(sphereGeo, sphereMat);
        scene.add(coreSphere);

        // Halo
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');   
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 1.5)'); 
        gradient.addColorStop(0.6, 'rgba(200, 220, 255, 0.4)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 128);
        
        const glowTexture = new THREE.CanvasTexture(canvas);
        
        // CORRECTION DU CARRÉ NOIR ICI :
        const glowMaterial = new THREE.SpriteMaterial({ 
            map: glowTexture, 
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false // <--- C'est cette ligne qui empêche le carré noir !
        });
        
        const coreGlow = new THREE.Sprite(glowMaterial);
        coreGlow.scale.set(300, 300, 1);
        scene.add(coreGlow);

        // --- 2. TENTACULES VECTORIELS ---
        const rayCount = 85; 
        const segmentsPerRay = 100;
        
        const positions = [];
        const colors = [];
        const indices = []; 
        const raysData = []; 

        let indexCounter = 0;

        for (let r = 0; r < rayCount; r++) {
            const angleBase = (r / rayCount) * Math.PI * 2;
            const phase = Math.random() * Math.PI * 2;
            const speedVar = 0.5 + Math.random() * 0.5;
            const ampVar = 10.0 + Math.random() * 20.0;

            for (let s = 0; s < segmentsPerRay; s++) {
                const t = s / (segmentsPerRay - 1); 
                
                // Rayon total = 10 + 500 = 510 (Similaire à avant)
                const dist = 10 + t * 550; 

                positions.push(0, 0, 0);

                const intensity = 0.8 + t * 0.2; 
                colors.push(intensity, intensity, intensity);

                raysData.push({ 
                    angleBase, dist, t, phase, speedVar, ampVar, index: indexCounter 
                });

                if (s < segmentsPerRay - 1) {
                    indices.push(indexCounter, indexCounter + 1);
                }
                indexCounter++;
            }
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setIndex(indices);
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.LineBasicMaterial({
            vertexColors: true, 
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.6, 
            depthWrite: false 
        });

        const linesMesh = new THREE.LineSegments(geometry, material);
        scene.add(linesMesh);

        // === ANIMATION ===
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime() / 3.0;

            const pulse = 1 + Math.sin(time * 8) * 0.03;
            coreSphere.scale.setScalar(pulse);
            coreGlow.scale.setScalar(130 * (0.95 + Math.sin(time * 5) * 0.05));

            const posArray = geometry.attributes.position.array;

            for (let i = 0; i < raysData.length; i++) {
                const d = raysData[i];
                const idx = d.index * 3;

                const wave = Math.sin(d.dist * 0.03 - time * 3.5 * d.speedVar + d.phase);
                const displacement = wave * (d.t * d.ampVar);
                const angle = d.angleBase + displacement * 0.005; 
                const height = Math.sin(time * 2.0 + d.dist * 0.02) * (d.t * 20.0);

                posArray[idx] = Math.cos(angle) * d.dist;
                posArray[idx+1] = height;
                posArray[idx+2] = Math.sin(angle) * d.dist;
            }

            geometry.attributes.position.needsUpdate = true;
            linesMesh.rotation.y = time * 0.05;

            renderer.render(scene, camera);
        }

        // === CONTROLES ===
        let isDragging = false;
        let lastX, lastY;
        window.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                camTheta -= (e.clientX - lastX) * 0.005;
                camPhi -= (e.clientY - lastY) * 0.005;
                camPhi = Math.max(0.1, Math.min(Math.PI - 0.1, camPhi));
                lastX = e.clientX; lastY = e.clientY;
                updateCamera();
            }
        });
        window.addEventListener('wheel', e => {
            camRadius = Math.max(80, Math.min(2000, camRadius + e.deltaY * 0.5));
            updateCamera();
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>