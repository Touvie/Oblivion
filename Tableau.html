<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Big Bang - Expansion 500</title>
    <style>
        body { margin: 0; background: black; overflow: hidden; cursor: grab; }
        body:active { cursor: grabbing; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- CAMERA : Ajustée pour expansion 500 ---
        let camRadius = 400; 
        let camTheta = Math.PI / 0.1;
        let camPhi = Math.PI / 0.1; 
        function updateCamera() {
            camera.position.x = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
            camera.position.y = camRadius * Math.cos(camPhi);
            camera.position.z = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
            camera.lookAt(0, 0, 0);
        }
        updateCamera();

        // --- SHADER LUMINEUX NÉON ---
        const vertexShader = `
            attribute float size;
            attribute vec3 customColor;
            varying vec3 vColor;
            void main() {
                vColor = customColor;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (450.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                float d = length(gl_PointCoord - vec2(0.5));
                if (d > 0.5) discard;
                float intensity = pow(1.0 - d * 2.0, 1.5);
                vec3 finalColor = mix(vColor, vec3(1.0, 1.0, 1.0), intensity * 0.75);
                gl_FragColor = vec4(finalColor * intensity * 4.0, intensity);
            }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });

        // === NOYAU (CORE) ===
        const coreCount = 15000;
        const coreGeo = new THREE.BufferGeometry();
        const corePos = new Float32Array(coreCount * 3);
        const coreCols = new Float32Array(coreCount * 3);
        const coreSizes = new Float32Array(coreCount);

        for (let i = 0; i < coreCount; i++) {
            const r = 12 * Math.cbrt(Math.random());
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            corePos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            corePos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            corePos[i*3+2] = r * Math.cos(phi);
            coreCols[i*3] = 1.0; coreCols[i*3+1] = 0.95; coreCols[i*3+2] = 0.85;
            coreSizes[i] = 1.2 + Math.random() * 2.0;
        }
        coreGeo.setAttribute('position', new THREE.BufferAttribute(corePos, 3));
        coreGeo.setAttribute('customColor', new THREE.BufferAttribute(coreCols, 3));
        coreGeo.setAttribute('size', new THREE.BufferAttribute(coreSizes, 1));
        scene.add(new THREE.Points(coreGeo, material));

        // === TENTACULES (EXPANSION 500) ===
        const rayCount = 85; 
        const partPerRay = 250; 
        const rayTotal = rayCount * partPerRay;
        const rayGeo = new THREE.BufferGeometry();
        const rayPos = new Float32Array(rayTotal * 3);
        const rayCols = new Float32Array(rayTotal * 3);
        const raySizes = new Float32Array(rayTotal);
        const rayData = [];

        for (let r = 0; r < rayCount; r++) {
            const angleBase = (r / rayCount) * Math.PI * 2;
            const phase = Math.random() * Math.PI * 2;
            for (let p = 0; p < partPerRay; p++) {
                const t = p / partPerRay;
                const dist = 12 + t * 500; // EXPANSION FIXÉE À 500
                rayData.push({ angleBase, dist, t, phase });

                const color = new THREE.Color();
                // Dégradé : Blanc -> Jaune -> Orange -> Rouge
                if (t < 0.08) color.setRGB(1, 1, 1);
                else if (t < 0.25) color.setRGB(1, 0.9, 0.3);
                else if (t < 0.6) color.setRGB(1, 0.35, 0);
                else color.setRGB(0.7, 0, 0.05);

                const idx = r * partPerRay + p;
                rayCols[idx*3] = color.r;
                rayCols[idx*3+1] = color.g;
                rayCols[idx*3+2] = color.b;
                raySizes[idx] = 1.0 + (1.0 - t) * 2.0;
            }
        }
        rayGeo.setAttribute('position', new THREE.BufferAttribute(rayPos, 3));
        rayGeo.setAttribute('customColor', new THREE.BufferAttribute(rayCols, 3));
        rayGeo.setAttribute('size', new THREE.BufferAttribute(raySizes, 1));
        const tentacles = new THREE.Points(rayGeo, material);
        scene.add(tentacles);

        // === ANIMATION : VITESSE / 3 ===
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime() / 3.0;

            const pos = rayGeo.attributes.position.array;
            for (let i = 0; i < rayData.length; i++) {
                const d = rayData[i];
                // Ondulation sinus adaptée à 500 unités
                const wave = Math.sin(d.dist * 0.03 - time * 3.5 + d.phase) * (d.t * 30.0);
                const angle = d.angleBase + wave * 0.005;

                pos[i*3] = Math.cos(angle) * d.dist; 
                pos[i*3+1] = Math.sin(time * 2.0 + d.dist * 0.02) * d.t * 20.0; // Hauteur
                pos[i*3+2] = Math.sin(angle) * d.dist;
            }
            rayGeo.attributes.position.needsUpdate = true;
            tentacles.rotation.y = time * 0.03;

            renderer.render(scene, camera);
        }

        // === CONTROLES SOURIS ===
        let isDragging = false;
        let lastX, lastY;
        window.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', e => {
            if (isDragging) {
                camTheta -= (e.clientX - lastX) * 0.005;
                camPhi -= (e.clientY - lastY) * 0.005;
                camPhi = Math.max(0.1, Math.min(Math.PI - 0.1, camPhi));
                lastX = e.clientX; lastY = e.clientY;
                updateCamera();
            }
        });
        window.addEventListener('wheel', e => {
            camRadius = Math.max(80, Math.min(2000, camRadius + e.deltaY * 0.5));
            updateCamera();
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>